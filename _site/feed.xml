<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/blog/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/blog/" rel="alternate" type="text/html" hreflang="en" /><updated>2023-08-05T17:54:50+02:00</updated><id>http://localhost:4000/blog/feed.xml</id><title type="html">Dusan’s Blog</title><subtitle>A blog about software development and other stuff</subtitle><entry><title type="html">Interesting Points about Hooks in React</title><link href="http://localhost:4000/blog/javascript/2023/03/15/interesting-points-about-hooks-react/" rel="alternate" type="text/html" title="Interesting Points about Hooks in React" /><published>2023-03-15T00:00:00+01:00</published><updated>2023-03-15T00:00:00+01:00</updated><id>http://localhost:4000/blog/javascript/2023/03/15/interesting-points-about-hooks-react</id><content type="html" xml:base="http://localhost:4000/blog/javascript/2023/03/15/interesting-points-about-hooks-react/"><![CDATA[<p>Hooks don’t replace your knowledge of React concepts. Instead, Hooks provide a more direct API to the React concepts you already know: props, state, context, refs, and lifecycle. As we will show later, Hooks also offer a new powerful way to combine them.</p>

<!--more-->

<p>Hooks allow you to reuse stateful logic without changing your component hierarchy.</p>

<h2 id="problems-with-class-components">Problems with Class Components</h2>
<p>Each lifecycle method often contains a mix of unrelated logic. For example, components might perform some data fetching in componentDidMount and componentDidUpdate. However, the same componentDidMount method might also contain some unrelated logic that sets up event listeners, with cleanup performed in componentWillUnmount.</p>

<p>Mutually related code that changes together gets split apart, but completely unrelated code ends up combined in a single method. This makes it too easy to introduce bugs and inconsistencies.</p>

<p>https://reactjs.org/docs/hooks-intro.html</p>]]></content><author><name></name></author><category term="javascript" /><summary type="html"><![CDATA[Hooks don’t replace your knowledge of React concepts. Instead, Hooks provide a more direct API to the React concepts you already know: props, state, context, refs, and lifecycle. As we will show later, Hooks also offer a new powerful way to combine them.]]></summary></entry><entry><title type="html">Comparing 2 Strings in JS, How would I do it?</title><link href="http://localhost:4000/blog/javascript/2022/02/17/comparing-two-strings/" rel="alternate" type="text/html" title="Comparing 2 Strings in JS, How would I do it?" /><published>2022-02-17T00:00:00+01:00</published><updated>2022-02-17T00:00:00+01:00</updated><id>http://localhost:4000/blog/javascript/2022/02/17/comparing-two-strings</id><content type="html" xml:base="http://localhost:4000/blog/javascript/2022/02/17/comparing-two-strings/"><![CDATA[<p>I watched this interesting video on youtube, about a codding assignement where you need to solve a logical problem in JS, and write a function that does some processing based on input data and needs to return the expected result, as it turns out this if very interesting for me to try and solve on my own, so in this post I’ll show my approach at this.</p>

<!--more-->

<p>Comparing 2 Strings in JS, How would I do it?
I watched this interesting video on youtube, about a codding assignement where you need to solve a logical problem in JS, and write a function that does some processing based on input data and needs to return the expected result, as it turns out this if very interesting for me to try and solve on my own, so in this post I’ll show my approach at this.</p>

<h2 id="the-instructions">The Instructions</h2>
<p>Create a function in JS that accepts 2 parameters, s1 and s2, which should be strings, and create some logic to create the longest common substring between them, while allowing any other characters as long as they don’t mess with the order of the longest common substring.
Example input and output:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// “DUSANTEST1” “CCTESTGSAG” =&gt; “TEST”</span>
<span class="c1">// “AGGTAB” “GXTXAYB” =&gt; “GTAB”</span>
</code></pre></div></div>

<h2 id="try-matching-each-letter">Try matching each letter</h2>
<p>My first thought was that I should start by taking each letter in s1 and comparing it to all of the letters in s2.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">getLongest</span><span class="p">(</span><span class="nx">s1</span><span class="p">,</span> <span class="nx">s2</span><span class="p">)</span> <span class="p">{</span>
<span class="c1">// * go through each of the letters in S1 and try to find the same in S2, but avoid characters already found, avoid finding items that preceed the already found</span>
<span class="kd">let</span> <span class="nx">found</span> <span class="o">=</span> <span class="p">[];</span>
<span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">s1</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// * find location in S2</span>
      <span class="kd">let</span> <span class="nx">s2Found</span> <span class="o">=</span> <span class="nx">s2</span><span class="p">.</span><span class="nf">indexOf</span><span class="p">(</span><span class="nx">s1</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
      <span class="k">if </span><span class="p">(</span><span class="nx">s2Found</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">found</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">s1</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
        <span class="nx">s2</span> <span class="o">=</span> <span class="nx">s2</span><span class="p">.</span><span class="nf">substr</span><span class="p">(</span><span class="nx">s2Found</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
<span class="k">return</span> <span class="nx">found</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="dl">''</span><span class="p">);</span>
<span class="p">};</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">found</span><span class="p">);</span> <span class="c1">// we print what was found</span>
</code></pre></div></div>

<p>What I figured after I wrote my initial for loop, is that I don’t want to keep searching in the entire s2 string with every character in s1, as it would not help with duplicate matches and the order.</p>

<p>So if an s1 character is found in s2 we want to start counting our match from there and trim our s2 string so we don’t match the same character again.</p>

<h2 id="another-loop">Another loop</h2>
<p>So the example above now works, but it doesn’t return the longest common substring, it only returns the first found substring.</p>

<p>We need a way to collect all possible combinations and compare which one is the longest. And because our current example basically starts from the first matched letter from s1, we need a way to test all letter combinations in s1 left to right, omitting incrementally.</p>

<h2 id="filtering-out-duplicates">Filtering out duplicates</h2>
<p>Finding the longest</p>

<h2 id="the-complete-function">The complete function</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">getLongest</span><span class="p">(</span><span class="nx">s1</span><span class="p">,</span> <span class="nx">s2</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">collection</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="kd">let</span> <span class="nx">longest</span> <span class="o">=</span> <span class="dl">""</span><span class="p">;</span>

  <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">w</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">w</span> <span class="o">&lt;</span> <span class="nx">s1</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">w</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">s1Search</span> <span class="o">=</span> <span class="nx">s1</span><span class="p">.</span><span class="nf">substr</span><span class="p">(</span><span class="nx">w</span><span class="p">);</span>

    <span class="kd">let</span> <span class="nx">s2Processing</span> <span class="o">=</span> <span class="nx">s2</span><span class="p">;</span>

    <span class="kd">let</span> <span class="nx">found</span> <span class="o">=</span> <span class="p">[];</span>

    <span class="c1">// * go through each of the letters in S1 and try to find the same in S2, but avoid characters already found, avoid finding items that preceed the already found</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">s1Search</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// * find location in S2</span>
      <span class="kd">let</span> <span class="nx">s2Found</span> <span class="o">=</span> <span class="nx">s2Processing</span><span class="p">.</span><span class="nf">indexOf</span><span class="p">(</span><span class="nx">s1Search</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
      <span class="k">if </span><span class="p">(</span><span class="nx">s2Found</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">found</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">s1Search</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
        <span class="nx">s2Processing</span> <span class="o">=</span> <span class="nx">s2Processing</span><span class="p">.</span><span class="nf">substr</span><span class="p">(</span><span class="nx">s2Found</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="nx">collection</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">found</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="dl">""</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="kd">const</span> <span class="nx">uniqueValues</span> <span class="o">=</span> <span class="p">[...</span><span class="k">new</span> <span class="nc">Set</span><span class="p">(</span><span class="nx">collection</span><span class="p">)];</span>

  <span class="c1">// go trough each of the items and count and write somewhere</span>

  <span class="nx">uniqueValues</span><span class="p">.</span><span class="nf">forEach</span><span class="p">((</span><span class="nx">value</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">longest</span><span class="p">.</span><span class="nx">length</span> <span class="o">&lt;=</span> <span class="nx">value</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">longest</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">});</span>

  <span class="c1">// feches unique items</span>
  <span class="k">return</span> <span class="nx">longest</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nf">getLongest</span><span class="p">(</span><span class="dl">"</span><span class="s2">aaaaabb</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">aaa</span><span class="dl">"</span><span class="p">));</span>
</code></pre></div></div>

<p>The above solution might not be the most performant solution, but its the simplest I found.</p>

<p>Finding the solution above took me quite some time, more than I expected initially. Not too proud to say that I had to look up what the substr() function actually returns, so you can say that I cheated a little, it’s all because the online code editor that I used didn’t have any code hinting.</p>

<p>Any feedback is much appreciated.</p>]]></content><author><name></name></author><category term="javascript" /><summary type="html"><![CDATA[I watched this interesting video on youtube, about a codding assignement where you need to solve a logical problem in JS, and write a function that does some processing based on input data and needs to return the expected result, as it turns out this if very interesting for me to try and solve on my own, so in this post I’ll show my approach at this.]]></summary></entry></feed>